<!DOCTYPE html>
<html>

<head>
  <link rel="stylesheet" type="text/css" href="../main.css">
  <script src="../main.js" type="text/javascript" defer></script>
</head>

<body>
  <div class="example">
    <nav>
      <a href="index.html">Back to TOC</a>
    </nav>
    <h1><a href="https://golang.org/ref/spec#Struct_types" target="_blank">Structs</a></h1>

    <p>Go’s structs are typed collections of fields. They’re useful for grouping data together to form records.</p>

    <button type="button" class="collapsible">Create</button>

    <div class="content">
      <pre>
<code>
type person struct {
  first string
  last  string
}
</code>
        </pre>
    </div>
    <button type="button" class="collapsible">Declare</button>

    <div class="content">
      Declare a variable of that struct type
      <pre>
<code>
p1 := person{
  first: "James",
  last:  "Bond",
}
</code>
        </pre>
    </div>
    <button type="button" class="collapsible">Access Attributes</button>

    <div class="content">
      Access the attributes inside a struct identifier
      <pre>
<code>
fmt.Println(p1) <span class="comment">//{James Bond}</span>
fmt.Println(p1.first) <span class="comment">//James</span>
fmt.Println(p1.last) <span class="comment">//Bond</span>
</code>
        </pre>
    </div>
    <button type="button" class="collapsible">Struct in struct</button>

    <div class="content">
      You can use structs inside of structs
      <pre>
<code>
type person struct {
  first string
  last  string
}
  
type secretAgent struct {
  person
  ltk bool
}

p1 := person{
  first: "James",
  last:  "Bond",
}

a1 := secretAgent{
  person: p1,
  ltk:    false,
}
</code>
        </pre>
    </div>
    <button type="button" class="collapsible">Anonymous Struct</button>

    <div class="content">
      An anonymous struct is one without a name. You specify the struct at the same time you declare a variable.
      You'll use an anonymous one when you need to pass it to a function for one time use.
      <pre>
<code>
p1 := struct {
  first string
  last  string
}{
  first: "James",
  last:  "Bond",
}

fmt.Println(p1) <span class="comment">//{James Bond}</span>
</code>
        </pre>
    </div>
    <button type="button" class="collapsible">Anonymous Struct Field</button>

    <div class="content">
      <p>
        The first important thing to note is that since we have defined <code>vehicle</code> to be an anonymous field, 
        it allows us to access its members as if they were members of <code>car</code>. If it wasn't an anonymous field
        then we would have to type <code>c.[fieldname].color</code>
      </p>
      <pre>
<code>
type vehicle struct {
  kind  string
  color string
}

type car struct {
  model string
  vehicle <span class="comment">//anonymous field since it has no name</span>
}

func main() {
  v := vehicle{kind: "car", color: "red"}
  c := car{model: "Nissan", vehicle: v}
  
  <span class="comment">// You can access the properties of "vehicle" directly</span>
  fmt.Println(c.model, c.kind, c.color)
}
  
</code>
        </pre>
    </div>
    <button type="button" class="collapsible"><span>Methods</span> <a
        href="https://golang.org/ref/spec#Function_declarations" target="_blank">Link</a></button>

    <div class="content">
      <p>
        Go supports methods defined on struct types. This is a way to attach methods to a struct.
      </p>

      <pre>
<code>
package main

import (
  "fmt"
)

type person struct {
  first string
  last  string
}

<span class="comment">// Adds this method to any TYPE of type "person"</span>
func (p person) quack() {
  fmt.Println(p.first, p.last)
}

<span class="comment">// value receiver: Changes made to "p" are not kept</span>
<span class="comment">// once we exit the method. We're working on a copy.</span>
func (p person) swap() {
  p.first, p.last = p.last, p.first
}

<span class="comment">// pointer receiver: Changes made to "p" are kept</span>
<span class="comment">// once we exit the method. We're working on the actual receiver</span>
func (p *person) swapPtr() {
  p.first, p.last = p.last, p.first
}

func main() {
  <span class="comment">//automatically attaches the quack() method</span>
  p1 := person{
    first: "James",
    last:  "Bond",
  }

  <span class="comment">//"James Bond"</span>
  p1.quack()

  <span class="comment">// "Before Swap:  James Bond"</span>
  fmt.Println("Before Swap: ", p1.first, p1.last)
  p1.swap()
  <span class="comment">// "After Swap:  James Bond"</span>
  fmt.Println("After Swap: ", p1.first, p1.last)
  
  <span class="comment">// "Before SwapPtr:  James Bond"</span>
  fmt.Println("Before SwapPtr: ", p1.first, p1.last)
  p1.swapPtr()
  <span class="comment">// "After SwapPtr:  Bond James"</span>
  fmt.Println("After SwapPtr: ", p1.first, p1.last)
}  
</code>
    </pre>

    <h3>Value or Pointer receiver?</h3>
    <ul>
      <li>Pointer receivers are more common</li>
      <li>For a structure always use one or the other, but never both</li>
      <li>Pointer receiver if modifying the value of the receiver</li>
      <li>Pointer receiver if working with a large struct</li>
    </ul>
    </div>

  </div>
</body>

</html>